[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to ShakaStats",
    "section": "",
    "text": "Bringing knowledge about statistics, machine learning, and data analysis software with a ü§ôüèæ"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Logistic Regression Analysis Example: Optimizing Expected Returns\n\n\n\nMachine Learning\n\nLogistic Regression\n\nOptimization\n\n\n\n\n\n\n\n\n\nNovember 7, 2025\n\n\nJosh Tomiyama\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Post With Code\n\n\n\nnews\n\ncode\n\nanalysis\n\n\n\n\n\n\n\n\n\nJanuary 6, 2026\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJanuary 3, 2026\n\n\nTristan O‚ÄôMalley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html",
    "href": "projects/logisticRegressionExample/index.html",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "",
    "text": "Last Update: January 06, 2026\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(arm)\nlibrary(gtsummary)\nlibrary(dplyr)\nlibrary(ggplot2)"
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#logistic-regression-compared-to-other-machine-learning-models",
    "href": "projects/logisticRegressionExample/index.html#logistic-regression-compared-to-other-machine-learning-models",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Logistic regression compared to other machine learning models",
    "text": "Logistic regression compared to other machine learning models\nThe important distinction between logistic regression and other machine learning models is that the statistical theory on the model parameters is well understood. For each of the \\(\\beta\\) parameters in our model, we know the statistical properties to allow inference through p-values or confidence intervals. Logistic regression is still a tool used today to understand, or infer, the relationship between a binary outcome and other data collected when statistical evidence is required to validate any findings.\nAlthough in most real-world scenarios the other machine learning models perform better in terms of predictiveness, logistic regression can sometimes still be a better model in terms of predictiveness. In my experience through classes and work projects, a logistic regression model is actually superior to the more sophisticated machine learning techniques of Gradient Boosted Trees and Random Forests under a few scenarios with respect to the AUC (area under the curve) performance metric.\nThe first scenario I‚Äôve come across is when the sample size is relatively small. The machine learning techniques tend to work very well when there is more data to help effectively learn the functional relationship between the data you have and the target outcome. I would say this would be the situation when your sample size is in the magnitude of a few hundreds or less. After that point, other machine learning techniques perform at their expected capacity.\nThe second scenario where logistic regression can prove better than tree based methods is if one is willing to both select the covariates that strongly relate to the outcome of interest and also identify how each covariate functionally relates to the outcome. To expand on what I mean by ‚Äúhow each covariate functionally relates to the outcome‚Äù, some examples of functional relationships are the usual linear relationship, quadratic relationship, or sinusoidal relationship. In mathematical terms you can propose the following models:\n\\(Linear: \\log(\\frac{\\pi_i}{1 - \\pi_i}) = x_i\\beta\\)\n\\(Quadratic: \\log(\\frac{\\pi_i}{1 - \\pi_i}) = x_i\\beta_1 + x_i^2\\beta_2\\)\n\\(Sinusoidal: \\log(\\frac{\\pi_i}{1 - \\pi_i}) = sin(x_i)\\beta\\)\nChoosing a functional relationship alone produces infinite possibilities for one to sort through in addition to just choosing which covariates to include in one‚Äôs analysis. The strength of tree based approaches is that they learn these relationships with enough data, but of course the tree won‚Äôt be as accurate as if one were to explicitly identify that ‚Äútrue‚Äù relationship when training a logistic regression. However, identifying the ‚Äútrue‚Äù functional relationship between the outcome and covariates is rather impractical when one has many different covariates to consider at once. So once again, when the data becomes sufficiently large, it is more practical to use a Gradient Boosted Tree model or Random Forest model.\nThe advantages and shortfalls of logistic regression compared to other machine learning techniques naturally extend to any generalized linear model such as linear regression. To be clear, I am NOT saying that in these scenarios generalized linear models will ALWAYS surpass the newer machine learning models and algorithms, but rather that these scenarios ALLOW generalized linear models to shine just as well, if not better, than their other machine learning counterparts in terms of predictiveness."
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#quick-exploratory-analysis-of-the-data-set",
    "href": "projects/logisticRegressionExample/index.html#quick-exploratory-analysis-of-the-data-set",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Quick Exploratory analysis of the Data Set",
    "text": "Quick Exploratory analysis of the Data Set\nWhen starting an analysis, it‚Äôs important to first summarize and get a feel of the data. This is a useful and important step as it informs what are reasonable models for the data and indicates the quality of the data.\n\nx_df %&gt;% \n  tbl_summary(\n    include = c(markup, cost, type, sold),\n    type = list(all_continuous() ~ \"continuous2\"),\n    statistic = list(\n      all_continuous() ~ c(\"{mean} ({sd})\", \"{median} ({p25}, {p75})\", \"[{min}, {max}]\")\n    ),\n    by = type)\nx_df %&gt;%\n  tbl_summary(\n    include = c(markup, cost, sold),\n    type = list(all_continuous() ~ \"continuous2\"),\n    statistic = list(\n      all_continuous() ~ c(\"{mean} ({sd})\", \"{median} ({p25}, {p75})\", \"[{min}, {max}]\")\n    ),\n    by = sold)\n\n\n\nTable¬†1: Summary Tables\n\n\n\n\n\n\n\n\n\n\n(a) Summary by Type\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\naccessories\nN = 8711\nclothes\nN = 1,5251\nshoes\nN = 6041\n\n\n\n\nmarkup\n\n\n\n\n\n\n\n\n¬†¬†¬†¬†Mean (SD)\n70 (28)\n68 (29)\n69 (29)\n\n\n¬†¬†¬†¬†Median (Q1, Q3)\n70 (45, 93)\n67 (43, 92)\n68 (44, 92)\n\n\n¬†¬†¬†¬†[Min, Max]\n[20, 120]\n[20, 120]\n[20, 120]\n\n\ncost\n\n\n\n\n\n\n\n\n¬†¬†¬†¬†Mean (SD)\n1,990 (386)\n2,022 (404)\n2,014 (404)\n\n\n¬†¬†¬†¬†Median (Q1, Q3)\n1,984 (1,731, 2,246)\n2,033 (1,750, 2,297)\n2,006 (1,734, 2,305)\n\n\n¬†¬†¬†¬†[Min, Max]\n[712, 3,263]\n[533, 3,587]\n[688, 3,153]\n\n\nsold\n82 (9.4%)\n242 (16%)\n118 (20%)\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Summary by Sold\n\n\n\n\n\n\n\n\n\n\nCharacteristic\n0\nN = 2,558\n1\nN = 442\n\n\n\n\nmarkup\n\n\n\n\n\n\n¬†¬†¬†¬†Mean (SD)\n75 (26)\n30 (8)\n\n\n¬†¬†¬†¬†Median (Q1, Q3)\n76 (54, 96)\n28 (24, 35)\n\n\n¬†¬†¬†¬†[Min, Max]\n[21, 120]\n[20, 57]\n\n\ncost\n\n\n\n\n\n\n¬†¬†¬†¬†Mean (SD)\n1,992 (395)\n2,123 (404)\n\n\n¬†¬†¬†¬†Median (Q1, Q3)\n1,991 (1,728, 2,258)\n2,129 (1,827, 2,405)\n\n\n¬†¬†¬†¬†[Min, Max]\n[533, 3,587]\n[1,023, 3,353]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(markup, cost, \n     main = \"cost vs markup\", \n     ylab = \"cost of production ($)\", \n     xlab = \"markup of product (%)\")\n\n\n\n\n\n\n\nFigure¬†1: Comparing cost and markup\n\n\n\n\n\nThe first table summarizes the different covariates and outcome by type. Inspecting the average and quartiles of markup and cost between the different types, we don‚Äôt notice any difference in the distributions. This implies that type is associated with neither the cost nor markup, which is a best case scenario for a logistic regression analysis. The proportion of successful sales is different among the product types with clothes and shoe products selling at a higher rate than the accessories. This implies that there may be an association between type and product sales. Clearly, there is an imbalance in the distribution of type in the data set, but we have enough cases of each product type such that including type in the logistic regression model shouldn‚Äôt be a problem.\nThe second table summarizes markup and the cost variables by whether the product sold (the 1 group) or not (the 0 group). Comparing these two groups, we can clearly see that markup is lower in the groups that sold and indicates a negative association between sales and markup. The distribution of cost shifts about 100 dollars higher in the group that sold and thus suggests a positive association between cost and sales.\nFinally, in the scatter plot comparing cost and markup, we observe random spread of the points. There is no indication of a linear or other functional relationship between markup and cost, which is an ideal scenario for logistic regression."
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#building-a-logistic-regression-model",
    "href": "projects/logisticRegressionExample/index.html#building-a-logistic-regression-model",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Building a logistic regression model",
    "text": "Building a logistic regression model\nFitting a logistic regression model in R is a simple one line of code. Since we know what the true generating parameters are above, let‚Äôs double check our work by comparing the fitted values to the true parameters.\n\nfit &lt;- glm(sold ~ 1 + markup + cost + type, \n           data = x_df,\n           family = binomial)\nci &lt;- confint(fit)\n\nWaiting for profiling to be done...\n\nresult &lt;- data.frame(truth = true_beta, \n                     est = coef(fit),\n                     ci_lwr = ci[,1],\n                     ci_upr = ci[,2])\n\nkable(result, digits = 4) %&gt;% \n  kable_styling()\n\n\n\nTable¬†2: Comparing estimates to true values. Estimates are on the log-odds scale\n\n\n\n\n\n\n\ntruth\nest\nci_lwr\nci_upr\n\n\n\n\n(Intercept)\n2.000\n1.7716\n0.7778\n2.7816\n\n\nmarkup\n-0.200\n-0.2045\n-0.2272\n-0.1837\n\n\ncost\n0.002\n0.0021\n0.0017\n0.0026\n\n\ntypeclothes\n1.000\n0.8584\n0.4595\n1.2656\n\n\ntypeshoes\n1.500\n1.8053\n1.3052\n2.3199\n\n\n\n\n\n\n\n\nAs expected with this rather large sample size, the estimates are fairly close to the true values and are well within the 95% confidence intervals. All of the parameter estimates are statistically significant as 0 is not within the confidence intervals, so this is a convincing model. At this step, one would normally interpret these values as odds ratios, but that is not the goal of this analysis, so I will skip the interpretation.\nWhen building a logistic regression model, one usually has to consider a few different models to find the best fit to the data. Let‚Äôs consider three other logistic regression models. One without type in the model but all other variables in the model:\n\\[\n\\log(\\frac{\\pi_i}{1 - \\pi_i}) = \\beta_0 + x_{markup} * \\beta_{markup} +\nx_{cost} * \\beta_{cost}\n\\]\na second model with a quadratic term for markup and including all the other variables:\n\\[\n\\log(\\frac{\\pi_i}{1 - \\pi_i}) = \\beta_0 + x_{markup} * \\beta_{markup} + x_{markup}^2 * \\beta_{markup^2} +\nx_{cost} * \\beta_{cost} + x_{type=shoes} * \\beta_{type=shoes} + x_{type = clothes}*\\beta_{type = clothes}\n\\]\nand finally a simple model with just markup:\n\\[\n\\log(\\frac{\\pi_i}{1 - \\pi_i}) = \\beta_0 + x_{markup} * \\beta_{markup}\n\\]\nThere are many model selection criteria to choose from and which one to use depends on the goal of the analysis. In this application, the goal is estimation and inference, so I would personally advocate for the Bayesian Information Criterion (BIC). The BIC is a quantity that expresses how well the proposed model fits the data while also balancing how many parameters are in a model. More parameters in a model results in a better fit to the data but too many parameters results in overfitting. The problem with an overfit model is the lack of generalizability to new data. Please refer to the BIC() documentation to see the formula for its calculation. BIC favors having less parameters in a model as compared to it‚Äôs counterpart the Akaike Information Criterion (AIC). Therefore, the BIC is sometimes the preferred model selection criterion when the goal is to identify what covariates to go into a model.\nLower values of BIC indicate a better statistical model for the data. A difference of at least 2 is the typical threshold to consider one model superior the other. For differences of less than 2 the models are about equivalent and the statistician must decide which model is superior.\n\nfit1 &lt;- glm(sold ~ 1 + markup + cost, \n           data = x_df,\n           family = binomial)\nfit2 &lt;- glm(sold ~ 1 + markup + I(markup^2) + cost + type, \n           data = x_df,\n           family = binomial)\nfit3 &lt;- glm(sold ~ markup, data = x_df, family = binomial)\n\ndf_model_selection &lt;- data.frame(model = c(\"True_model\", \"no_type\", \"quadratic_markup\", \"Simple_markup\"), \n                                 bic = c(BIC(fit), BIC(fit1), BIC(fit2), BIC(fit3))\n                                 ) \ndf_model_selection %&gt;%    \n  kable(digits = 2, caption = \"Smaller BIC indicates better model\") %&gt;%  \n  kable_styling()\n\n\n\nTable¬†3: Comparing Logistic Regression Models\n\n\n\n\nSmaller BIC indicates better model\n\n\nmodel\nbic\n\n\n\n\nTrue_model\n927.72\n\n\nno_type\n964.57\n\n\nquadratic_markup\n935.31\n\n\nSimple_markup\n1046.51\n\n\n\n\n\n\n\n\nUpon inspecting the BIC values, the true model is unsurprisingly the lowest BIC and thus the best model. Disregarding our knowledge of the true data generating model, the model chosen at this step strongly translates the trends observed in the exploratory data analysis step, and thus highlights the importance of exploring the data before building models. The simple model with just markup is clearly the worst model with the highest BIC, so although the simple model would drastically simplify our optimal estimation of \\(\\pi_i\\) in the next step, the data indicates a more complex relationship between the outcome and covariates is more appropriate.\nAlthough we only inspect 4 models here, usually one would explore many more models and spend the bulk of their time trying to figure out the best model. More complex relationships like interactions and different functional transformations of continuous variables could be considered. Based on the exploratory analysis, this does not seem necessary in this analysis."
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#assessing-model-assumptions",
    "href": "projects/logisticRegressionExample/index.html#assessing-model-assumptions",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Assessing Model Assumptions",
    "text": "Assessing Model Assumptions\nAssessing whether the model assumptions are violated is often overlooked when fitting a logistic regression model. The main ones to assess are linearity of covariates (assumption 2), independent sampling (assumption 3), and multicollinearity (assumption 4). Perfect separation (assumption 5) is normally a warning from R if that occurs.\nBased on the exploratory analysis earlier, multicollinearity is not likely not an issue in this data set. We know this for a fact because I generated the data independently. The exploratory analysis revealed that there wasn‚Äôt any clear relationship between pairs of the covariates, and all of the parameters in the model are statistically significant. These are both great signs that multicollinearity is not present. However, to formally check for multicollinearity, one can check the Variance Inflation Factors (VIFs) in the covariates. I‚Äôll skip this step for now but one can read more on VIF theory here: https://online.stat.psu.edu/stat462/node/180/ and how to calculate it using the car package in R here: https://www.r-bloggers.com/2023/12/exploring-variance-inflation-factor-vif-in-r-a-practical-guide/.\nI will note though that if one adds higher order terms in the regression, for example\n\\[\n\\log(\\frac{\\pi_i}{1 - \\pi_i}) = \\beta_0 + x_{markup} * \\beta_{markup} + x_{markup}^2 * \\beta_{markup^2}\n\\] then instead of the VIF one will need to inspect the Generalized Variance Inflation Factor (GVIF).\nThe hardest assumption to verify is the linearity assumption. This only applies to continuous covariates which are markup and cost in this example. We can use the binnedplot function in the arm package to assess this. What this function does is bin or discretize the continuous variable into equally spaced segments. Within each segment, calculate the residual for the observations via:\n\\[\n  residual_i = y_i - \\hat \\pi_i\n\\] where \\(\\hat \\pi_i\\) is calculated from a proposed logistic regression model. We inspect the plot to make sure that the residuals are randomly scattered around the \\(y = 0\\) horizontal line, there is no pattern in the residuals, and that at most ~5% of the residuals are outside of the confidence interval lines.\nThese binned residuals plots assume a large sample size for the statistical properties to hold. Specifically if the sample size is large within each bin, then the expected value of these residuals is 0 with known standard errors due to the Lindeberg-Feller central limit theorem. My personal rule-of-thumb is at least 30 observations to be reasonably confident in the approximation, but the more the better. Unfortunately, the binned plots from the arm package don‚Äôt throw warnings when the bins have small sample size, so some caution is needed when interpretting these plots. In addition to large sample sizes, for values of \\(\\hat \\pi_i\\) close to 0 or 1, the statistical theory does not hold, so bins with mostly very low or very high predicted values of \\(\\hat \\pi_i\\) are not as informative.\n\n## example on how the binned residual plot is constructed\nrng &lt;- range(x_df$cost) # min, max of markup\n## break up range into 3 equal parts\nbreakpoints &lt;- seq(from = rng[1],\n                   to = rng[2],\n                   by = diff(rng/3))\nmidpoints &lt;- (breakpoints[-1] + breakpoints[-length(breakpoints)]) / 2\nres &lt;- x_df$sold - predict(fit, type = 'response')\nres_df &lt;- data.frame(res = res,\n           bp = cut(x_df$cost, breaks = breakpoints))\nres_ave &lt;- aggregate(res ~ bp,\n                     data = res_df,\n                     FUN = mean)\nplot(x = x_df$cost, y = res, \n     xlab = \"cost\",\n     ylab = \"Residuals: observed - predicted\",\n     main  = \"How a binned residual plot is constructed\",\n     pch = 16)\npoints(x = midpoints, y = res_ave$res, \n       pch = 16, cex = 1.2,\n       col = 'red')\nabline(v = breakpoints, col = 'red')\nlegend(\"topright\", \n       legend = c(\"observed_residual\",\n                  \"average_residual\"),\n       col = c('black', 'red'),\n       pch = 16)\n\n\n\n\n\n\n\n\nLet‚Äôs look at several binned residual plots to assess whether our proposed model is reasonable.\n\nres &lt;- residuals(fit, type = \"response\")\nbinnedplot(x = fitted(fit),\n           y = res, \n           nclass=NULL, \n           xlab=\"Expected Values\", \n           ylab=\"Average residual\", \n           main=\"Binned residual plot\")\n\n\n\n\n\n\n\nbinnedplot(x = x_df$markup,\n           y = res, \n           nclass=NULL, \n           xlab=\"Binned markup\", \n           ylab=\"Average residual\", \n           main=\"Binned residual plot of markup\")\n\n\n\n\n\n\n\nbinnedplot(x = x_df$cost,\n           y = res, \n           nclass=NULL, \n           xlab=\"Binned cost\", \n           ylab=\"Average residual\", \n           main=\"Binned residual plot of cost\")"
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#relationship-between-x_markup-and-pi_i",
    "href": "projects/logisticRegressionExample/index.html#relationship-between-x_markup-and-pi_i",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Relationship between \\(x_{markup}\\) and \\(\\pi_i\\)",
    "text": "Relationship between \\(x_{markup}\\) and \\(\\pi_i\\)\nNow that we have decided on a logistic regression model, let‚Äôs explore the relationship between markup and the probability of selling the product. The relationship between markup and the log-odds might be linear, but when we invert the problem to get the relationship between markup and the probability it is certainly non-linear. To produce this non-linear relationship, we can invert the log-odds back to the probability scale through the following formula:\n\\[\n\\pi_i = (1 + \\exp[-(\\beta_0 + x_{markup} * \\beta_{markup} +\nx_{cost} * \\beta_{cost} + x_{type=shoes} * \\beta_{type=shoes} + x_{type = clothes}*\\beta_{type = clothes})])^{-1}\n\\]\nWe are specifically interested in how markup relates to the probability of selling, but we have the other data variables in the formula. Before exploring how the probability of selling changes over a range of values for markup, it is pertinent to choose some representative values for cost and type. To start with, let‚Äôs set the cost level to be the observed average cost level and let type be the most common type in the data set to provide a curve.\n\n## there isn't a mode function in base R\ngetMode &lt;- function(x){\n  lx &lt;- levels(x)\n  ux &lt;- unique(lx)\n  factor(ux[which.max(tabulate(match(lx, ux)))], levels = lx)\n}\nrange_markup &lt;- seq(from = 0, to = 75, by = 1)\nmode_type &lt;- getMode(x_df$type)\nmean_cost &lt;- mean(x_df$cost)\nnew_x_df &lt;- data.frame(\"markup\" = range_markup,\n                       \"cost\" = mean_cost,\n                       \"type\" = mode_type)\n\npreds &lt;- predict(fit, newdata = new_x_df, se.fit = TRUE)\npreds_ci_upr &lt;- preds$fit + qnorm(0.975)*preds$se.fit\npreds_ci_lwr &lt;- preds$fit - qnorm(0.975)*preds$se.fit\nprobs_df &lt;- data.frame(pred_prob = inverse_logit(preds$fit),\n                       pred_prob_lwr = inverse_logit(preds_ci_lwr),\n                       pred_prob_upr = inverse_logit(preds_ci_upr),\n                       markup = range_markup)\n\ntrue_probs &lt;- model.matrix(~ markup + cost + type, data = new_x_df) %*% true_beta\nprobs_df$true_probs &lt;- inverse_logit(true_probs)\n\n\nggplot(probs_df) + \n  ## probability curve predicted from logistic regression in black\n  geom_line(aes(x = markup, y = pred_prob)) + \n  ## 95% wald CI in red\n  geom_line(aes(x = markup, y = pred_prob_upr), col = \"red\") + \n  geom_line(aes(x = markup, y = pred_prob_lwr), col = \"red\") + \n  ## probability curve using true values will be in blue\n  geom_line(aes(x = markup, y = true_probs), col = \"blue\") + \n  ggtitle(paste0(\"Probablity of Selling Product vs markup percentage\"),\n          subtitle = paste0(\"type = \", mode_type[1], \n                            \"  cost = \", \n                            round(mean_cost[1], digits = 2)\n                            )\n  ) + \n  labs(x = \"markup (%)\", y = \"Probability of Selling Product\")\n\n\n\n\n\n\n\n\nAs expected, due to how well our estimates of the parameters are, the estimated probability curve in black is mostly overlapped by expected probabilities calculated from the true parameters in blue. As we can see from the graph above, the probability of selling decreases as markup increases. This isn‚Äôt surprising given that the true parameter for markup is -0.02.\nLet‚Äôs plot the differences between the true and predicted probabilities to really show how small the difference in magnitude is. We can see that the probabilities only differ at most by 0.02. Depending on the application context, this can be a meaningful difference or not, but for this application let‚Äôs assume that an underestimation of 0.02 is a reasonably close estimate.\n\nplot(x = probs_df$markup, \n     y = probs_df$true_probs - probs_df$pred_prob,\n     type = 'h',\n     ylab = \"True Prob - Pred Prob\",\n     xlab = \"markup\",\n     main = \"Difference between True and Predicted Probabilities\")\n\n\n\n\n\n\n\nFigure¬†2: Differences between predicted probability and true probability"
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#calculating-the-optimal-markup",
    "href": "projects/logisticRegressionExample/index.html#calculating-the-optimal-markup",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Calculating the Optimal markup",
    "text": "Calculating the Optimal markup\nWe can propose the following function to express a balance between optimizing cost markup while increasing the probability of successfully selling the product:\n\\(f(x_{markup}) = (1 + \\frac{x_{markup}}{100})x_{cost} \\pi_i\\)\nThis function is derived from the idea of the expected total revenue generated by a new product. The new products total revenue is expressed as \\((1 + \\frac{x_{markup}}{100})*x_{cost}\\) and the expected value of a new observation \\(Y_i\\) is \\(\\pi_i\\) because \\(Y_i\\) is a Bernoulli random variable (see appendix for small derivation). Thus, the expected total revenue generated from this product is the multiplication of these two quantities.\nThe calculation of \\(\\pi_i\\) depends on \\(x_{markup}\\) and \\(x_{cost}\\).\n\nexpected_return &lt;- function(markup, cost, type, fit, log = FALSE){\n  new_data &lt;- data.frame(markup = markup,\n                         cost = cost,\n                         type = type)\n  # if(markup &lt; 0){\n  #   return(-Inf)\n  # }\n  \n  if(log){\n   ### doing optimization on the log scale is more stable, if markup &gt; 0\n    log(1 + markup/100) + log(cost) + \n      log(predict(fit, newdata = new_data, type = \"response\"))\n  }else{\n   (1 + markup/100)*cost * #total sale price\n    predict(fit, newdata = new_data, type = \"response\") #prob success \n  }\n}\n\noptimal_vals &lt;- optim(par = 50, \n      fn = expected_return, \n      method = \"BFGS\",\n      control = list(fnscale = -1), # do maximization not minimization\n      # These params don't change\n      cost = mean_cost[1], type = mode_type[1], fit = fit \n      )\n\nif(optimal_vals$convergence != 0){\n  stop(\"The numerical optimization did not converge\")\n}else{\n  new_data &lt;- data.frame(markup = optimal_vals$par,\n                         cost = mean_cost[1],\n                         type = mode_type[1])\n  optimal_prob_success &lt;- inverse_logit(predict(fit, new_data))\n  optimal_df &lt;- data.frame(optimal_markup = optimal_vals$par,\n                           expected_total_cost = optimal_vals$value,\n                           type = mode_type[1],\n                           cost = mean_cost[1],\n                           prob_success = optimal_prob_success)\n  kable(optimal_df, digits = 3, align = 'c') %&gt;%\n    kable_styling()\n}\n\n\n\n\noptimal_markup\nexpected_total_cost\ntype\ncost\nprob_success\n\n\n\n\n14.48\n2203.908\naccessories\n2011.027\n0.957\n\n\n\n\n\nFrom this analysis, we find that for an accessory product that costs of $2011.03 to produce, the optimal markup is about 14.48 percent. This results in a total revenue generated of $2203.91.\nAlthough our formula calculates an optimal markup of 14.48 percent, we need to keep in mind that the range of markup in the data set are values between 20 and 120 percent. Thus, a markup of 14.48 percent is outside the region covered by the data. I would suggest collecting more data in this range before widely adopting this decision rule.\nIn this section we only looked at one specific combination of covariates. Of course, we may want to consider cases with combinations of product costs and product types. To explore these different scenarios more easily, I‚Äôve created a Rshiny dashboard that‚Äôll be linked below when it‚Äôs done."
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#hypothetical-impact-of-optimal-markup-strategy",
    "href": "projects/logisticRegressionExample/index.html#hypothetical-impact-of-optimal-markup-strategy",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Hypothetical Impact of Optimal Markup strategy",
    "text": "Hypothetical Impact of Optimal Markup strategy\nLet‚Äôs assess the business impact of this optimal markup strategy is in terms of two important outcomes:\n\nThe change in successful sales compared to the observed sales data\nThe change in revenue generated compared to the observed revenue\n\nFor each point in our data set, we will substitute the observed optimal markup strategy with the optimal markup and check the change in sales and revenue.\n\ncalc_optimal_markup &lt;- function(cost, type, fit){\n  optim(par = 50, \n      fn = expected_return, \n      method = \"BFGS\",\n      control = list(fnscale = -1), # do maximization not minimization\n      # These params don't change\n      cost = cost, type = type, fit = fit \n      )  \n}\n\noptimal_markups &lt;- mapply(calc_optimal_markup, \n                          cost = x_df$cost, \n                          type = x_df$type, \n                          MoreArgs = list(fit = fit))\noptimal_x_df &lt;- x_df\noptimal_x_df$markup &lt;- unlist(optimal_markups[1,])\n\nhist(optimal_x_df$markup)\n\n\n\n\n\n\n\nhypothetical_probs &lt;- predict(fit, \n                              newdata = optimal_x_df, \n                              type = 'response')\nest_probs &lt;- predict(fit, newdata = x_df, type = 'response')\n\nset.seed(2013)\nexpected_results &lt;- replicate(5000,\n          expr = {\n            hypothetical_success &lt;- rbinom(sample_size, 1, hypothetical_probs)\n            c(change_sales = sum(hypothetical_success) - sum(x_df$sold),\n              change_rev = sum(hypothetical_success * (1 + optimal_x_df$markup/100)*x_df$cost) - \n                           sum(x_df$sold * (1 + x_df$markup/100)*x_df$cost)\n            )\n          })\nobs_revenue &lt;- sum(x_df$sold * (1 + x_df$markup/100)*x_df$cost)\n\noptimal_results &lt;- data.frame(ave_change_sales = mean(expected_results[1,]),\n                              ave_change_revenue = mean(expected_results[2,]),\n                              ave_percent_change_sales = mean(expected_results[1,])/sum(x_df$sold),\n                              ave_percent_change_revenue = mean(expected_results[2,]) / obs_revenue)\noptimal_results\n\n  ave_change_sales ave_change_revenue ave_percent_change_sales\n1         2433.894            5664458                 5.506547\n  ave_percent_change_revenue\n1                     4.6332"
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#model-misspecification",
    "href": "projects/logisticRegressionExample/index.html#model-misspecification",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Model Misspecification",
    "text": "Model Misspecification\nOne may be tempted to fit a simpler logistic regression model that just includes markup and an intercept term because markup is the only relationship we are interested in exploring. In the optimization step outline earlier, this model simplifies the calculations significantly as we do not need to set fixed values for type and cost. However, if we choose to ignore the ‚Äútrue‚Äù relationship between the data variables and the outcome then we introduce significant bias in our estimates and predictions. Using the same data from earlier, let‚Äôs inspect the relationship of the estimated probability of recovery and markup under this simpler model:\n\\[\n  \\log(\\frac{\\pi_i}{1 - \\pi_i}) = \\beta_0 + x_{markup}*\\beta_{markup}\n\\]\n\nfit_reduced &lt;- glm(sold ~ markup, data = x_df, family = binomial()) \n# summary(fit_reduced)  \nnew_x_df &lt;- data.frame(\"markup\" = range_markup,                        \n                       \"cost\" = mean_cost,                        \n                       \"type\" = mode_type)  \n\npreds &lt;- predict(fit_reduced, newdata = new_x_df, se.fit = TRUE) \npreds_ci_upr &lt;- preds$fit + qnorm(0.975)*preds$se.fit \npreds_ci_lwr &lt;- preds$fit - qnorm(0.975)*preds$se.fit \nprobs_df &lt;- data.frame(pred_prob = inverse_logit(preds$fit), \n                       pred_prob_lwr = inverse_logit(preds_ci_lwr), \n                       pred_prob_upr = inverse_logit(preds_ci_upr),  \n                       markup = range_markup)  \ntrue_probs &lt;- model.matrix(~ markup + cost + type, data = new_x_df) %*% true_beta \nprobs_df$true_probs &lt;- inverse_logit(true_probs)  \n# mean(probs_df$pred_prob - probs_df$true_probs)   \nggplot(probs_df) +    \n  geom_line(aes(x = markup, y = pred_prob)) +    \n  geom_line(aes(x = markup, y = pred_prob_upr), col = \"red\") +    \n  geom_line(aes(x = markup, y = pred_prob_lwr), col = \"red\") +    \n  geom_line(aes(x = markup, y = true_probs), col = \"blue\") +    \n  ggtitle(paste0(\"Probablity of sale vs markup\"),\n          subtitle = paste0(\"type = \", mode_type[1],  \n                            \"  cost = \", \n                            round(mean_cost[1], digits = 2)   \n                            )   \n          )\n\n\n\n\n\n\n\n\nVery clearly, the true probability curve in blue is outside of the 95% confidence intervals for most of values of markup. The bias is mild at first but quickly diverges after around markup = 20. In this example curve, the estimated probability is higher than the true probability so any decisions made off the estimated probability will be over optimistic and thus lead to waste of markup doses. This clearly highlights the importance of an exploratory analysis in addition to model selection steps to avoid bias in the logistic regression model."
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#influential-data-points-and-sample-size",
    "href": "projects/logisticRegressionExample/index.html#influential-data-points-and-sample-size",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Influential Data Points and Sample Size",
    "text": "Influential Data Points and Sample Size\nThis question has come to me multiple times where sometimes the data is ‚Äúbiased‚Äù in some way where some subgroup of the data is underrepresented. The specific case we‚Äôll focus on is when some interval of values for a continuous covariate are not observed. For example, suppose that in the data we didn‚Äôt observe any points that costed between 2000 and 2100. Is this necessarily a problem? Well, it depends on whether these unobserved values follow the same pattern as the rest of the observed data.\nFirst, one needs to consider what the application of the study is. If the analysis is for a scientific experiment and the goal is inference, then generally no this violation reveals some error in the experimental setup and thus the inference is hard to justify. If we are not in such a strict scenario, such as the scenario presented in the problem, well then the bias can be a problem, but it depends on the truth, the quality of the data, and the sample size.\nTo simulate this scenario, we will bias the data set from earlier in two (rather extreme) ways:\n\nPeople with a cost in the range of 2000-2100mg chose not to participate in the study.\nPeople with markup in the range of 70-80% chose not to participate in the study\n\n\nx_df_bias &lt;- filter(x_df, cost &lt; 2000 | cost &gt; 2100)\n\nfit_bias &lt;- glm(sold ~ 1 + markup + cost + type, \n                data = x_df_bias,\n                family = binomial)\n\nci_bias &lt;- confint(fit_bias)\n\nWaiting for profiling to be done...\n\nresult &lt;- data.frame(truth = true_beta, \n                     full_est = coef(fit),\n                     bias_est = coef(fit_bias),\n                     bias_ci_lwr = ci_bias[,1],\n                     bias_ci_upr = ci_bias[,2])\nkable(result, digits = 4, caption = \"Estimates when cost is biased\") %&gt;% \n  kable_styling()\n\n\nEstimates when cost is biased\n\n\n\ntruth\nfull_est\nbias_est\nbias_ci_lwr\nbias_ci_upr\n\n\n\n\n(Intercept)\n2.000\n1.7716\n1.7881\n0.7845\n2.8097\n\n\nmarkup\n-0.200\n-0.2045\n-0.2046\n-0.2284\n-0.1828\n\n\ncost\n0.002\n0.0021\n0.0022\n0.0017\n0.0026\n\n\ntypeclothes\n1.000\n0.8584\n0.8135\n0.3934\n1.2423\n\n\ntypeshoes\n1.500\n1.8053\n1.7858\n1.2682\n2.3194\n\n\n\n\nx_df_bias2 &lt;- filter(x_df, markup &lt; 70 | markup &gt; 80)\n\nfit_bias2 &lt;- glm(sold ~ 1 + markup + cost + type, \n                data = x_df_bias2,\n                family = binomial)\n\nci_bias &lt;- confint(fit_bias2)\n\nWaiting for profiling to be done...\n\nsample_sizes &lt;- data.frame(full = sample_size,\n                           bias1 = nrow(x_df_bias),\n                           bias2 = nrow(x_df_bias2))\n\nresult &lt;- data.frame(truth = true_beta,\n                     full_est = coef(fit),\n                     bias_est = coef(fit_bias2),\n                     bias_ci_lwr = ci_bias[,1],\n                     bias_ci_upr = ci_bias[,2])\nkable(result, digits = 4, caption = \"Estimates when markup is biased\") %&gt;%\n  kable_styling()\n\n\nEstimates when markup is biased\n\n\n\ntruth\nfull_est\nbias_est\nbias_ci_lwr\nbias_ci_upr\n\n\n\n\n(Intercept)\n2.000\n1.7716\n1.7590\n0.7637\n2.7703\n\n\nmarkup\n-0.200\n-0.2045\n-0.2040\n-0.2267\n-0.1830\n\n\ncost\n0.002\n0.0021\n0.0021\n0.0017\n0.0026\n\n\ntypeclothes\n1.000\n0.8584\n0.8577\n0.4590\n1.2646\n\n\ntypeshoes\n1.500\n1.8053\n1.8034\n1.3035\n2.3177\n\n\n\n\n\nEven though we excluded a specific portion of our target population the estimates shifted but not by a lot. In fact, the inference is still rather okay under these conditions despite the bias (see appendix: simulation study of bias in estimates due to interval of missing values). This is actually not completely unexpected and relates to the concept of influential data points when conducting a data analysis. There are multiple ways to measure influence in data with respect to a generalized linear model, the one most pertinent to this concept is DFBETA(S).\nDFBETA(S) measures the change in a parameter estimate when a single data point is deleted from the model. The formula to calculate this measurement is expressed as:\n\\[DFBETAS_j = \\frac{\\hat \\beta_j - \\hat \\beta_{(i)j}}{SE(\\hat \\beta_j)}\\]\nWhere \\(j\\) is the index for each beta parameter in the regression model, \\(\\hat \\beta_{(i)j}\\) is the estimated beta parameter when the \\(i\\)th data point is deleted, and \\(SE(\\hat \\beta_j)\\) is the standard error for the \\(\\beta_j\\) parameter.\nWe can calculate this for each of the data points in our sample and a rule of thumb is that points with a DFBETA(S) greater than \\(\\pm \\frac{2}{\\sqrt n}\\) are highly influential where \\(n\\) is the sample size of the data. The S in DFBETA(S) stands for standardized and is why the denominator is the standard error of \\(\\hat \\beta_j\\). The parentheses in the name are just to emphasize the standardization part, I‚Äôll drop them from here on out.\nLet‚Äôs inspect the DFBETAS for the full model to get an idea of how influential our data is.\n\ndfbetas_vals &lt;- data.frame(dfbetas(fit)) \ncolnames(dfbetas_vals)[1] &lt;- \"intercept\" \nthreshold &lt;- sqrt(4/sample_size) \n\nfor(i in 1:ncol(dfbetas_vals)){ \n  y &lt;- dfbetas_vals[,i] \n  plot(y, \n       type = 'h', \n       main = paste0(\"DFBETAS plot for \", colnames(dfbetas_vals)[i]),\n       ylim = c(min(c(y, -1*threshold)), max(c(y, threshold)))\n       ) \n  abline(h = c(-1,1)*threshold, col = 'red') \n  text(x = 0, \n       max(y), \n       adj = 0, \n       paste0(\"Proportion of highly influential points = \", \n              mean(abs(y) &gt; threshold)) \n       ) \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# idx &lt;- abs(dfbetas_vals$markup) &gt; threshold\n# summary(x_df[idx,])\n# summary(x_df)\n\nHere we can see somewhere around 10% of the points are influential relative to the \\(\\pm \\frac{2}{\\sqrt n}\\) cut off for each of the beta parameters in the logistic regression. In a real world analysis we would inspect these points to determine if there is a pattern emerging from these influential points and appropriately exclude or try to adjust for any implied bias.\nAlthough not immediately obvious from the formula for DFBETAS, the sample size impacts how influential a single data point is on the estimation. Generally speaking, the larger the sample size then the lower magnitude of the influence of a single data point on estimating parameters. Thus, for a large sample size like the one in this simulated data set, the influence is small and is the reason why deleting a small portion of the data set had minimal effect on the parameter estimates.\nThe lesson here is that, for any ‚Äúbiased‚Äù data set, the influence may or may not strongly impact the parameters estimates depending on whether the biased data excluded any of these highly influential data points. Because we are in the context of a simulation problem, it‚Äôs obvious to us how big this influence is because we know the truth. In real applications, we never know how big the influence is; all we know is that a bias in estimates will exist. For instance, if the data was biased in a way that a subset of the target population is excluded, then we will never know how those unobserved data points would impact the parameter estimates. This is where statistical analysis becomes a bit more of an art than a science.\n\nsimulate_fit_data &lt;- function(i, bias_data = TRUE, ...){\n  sample_size &lt;- 3000\n\n  true_beta &lt;- c(2, # intercept\n                 -0.2, # markup\n                 0.002, # cost\n                 1, # type=clothes\n                 1.5 )# type=shoes\n  \n  ### Simulate data\n  \n  type &lt;- sample(c(\"accessories\", \"clothes\", \"shoes\"), \n                 size = sample_size,\n                 replace = TRUE,\n                 prob = c(0.3, 0.5, 0.2))\n  cost &lt;- rnorm(sample_size, mean = 2000, sd = 400)\n  markup &lt;- runif(sample_size, min = 20, max = 120)\n  \n  ### make markup and cost are above 0\n  \n  markup &lt;- ifelse(markup &lt;= 0, 10, markup)\n  cost &lt;- ifelse(cost &lt;= 0, 2000, cost)\n  \n  # convert type into a factor variable to prepare for analysis\n  \n  type &lt;- factor(type, levels = c(\"accessories\", \"clothes\", \"shoes\"))\n  \n  x_df &lt;- data.frame(markup = markup, cost = cost, type = type)\n  \n  # get x_matrix\n  \n  x_matrix &lt;- model.matrix(~ 1 + markup + cost + type, data = x_df)\n  \n  #simulated log-odds per person\n  \n  log_odds &lt;- x_matrix %*% true_beta\n  \n  #convert log_odds to probabilities\n  \n  inverse_logit &lt;- function(x){(1 + exp(-x))^-1}\n  true_probs &lt;- inverse_logit(log_odds)\n  \n  # get the outcome\n  sold &lt;- rbinom(sample_size, 1, true_probs)\n  x_df$sold &lt;- sold\n  x_df\n  if(bias_data){\n    x_df_bias &lt;- x_df_bias &lt;- filter(x_df, cost &lt; 2000 | cost &gt; 2100)\n  }else{\n    x_df_bias &lt;- x_df\n  }\n  \n  fit &lt;- glm(sold ~ 1 + markup + cost + type, \n           data = x_df_bias,\n           family = binomial)\n  bias &lt;- coef(fit) - true_beta\n  ci &lt;- confint(fit)\n  ## check whether true parameters are within the confidence interval\n  cover &lt;- (ci[,1] &lt; true_beta) & (true_beta &lt; ci[,2])\n  out &lt;- c(bias, cover)\n  names(out) &lt;- c(names(bias), paste0(\"cover\", names(bias)))\n  out\n}\nset.seed(123123)\nlibrary(parallel)\ncl &lt;- makeCluster(detectCores() - 1)\nclusterEvalQ(cl, suppressPackageStartupMessages(library(dplyr)))\nclusterSetRNGStream(cl)\nnreps &lt;- 10000\nrep_results_biased &lt;- parSapply(cl, 1:nreps, simulate_fit_data, bias_data = TRUE)\nrep_results &lt;- parSapply(cl, 1:nreps, simulate_fit_data, bias_data = FALSE)\nstopCluster(cl)\nrowMeans(rep_results)\nrowMeans(rep_results_biased)\n\n\nWhat to do about percieved bias in a data set\nFor each of the bias scenarios, I would first investigate why the sampling bias occurred. Perhaps it was an expected phenomena such as one does not sell products at those cost levels. In this case, we simply redefine the target population of inference to exclude that unobserved sub‚Äìpopulation.\nIf the sampling bias was not expected in the data and it isn‚Äôt feasible to collect data from missing sub-population, then what to do next really depends. First I would assess how well the model fits the data and the quality of the data. The data in this example is simulated, so the data quality is perfect (i.e.¬†no correlation between covariates, large enough sample size). An easy next step is to look at some measures of internal model validity like a calibration curve between the predictions and the observed values and cross validation.\nTODO: Explanation of calibration curves goes here\n\nlibrary(CalibrationCurves)\nval.prob.ci.2(predict(fit_bias, type = \"response\"), fit_bias$y, main = \"Biased cost sampling\")\n\n\n\n\n\n\n\n\nCall:\nval.prob.ci.2(p = predict(fit_bias, type = \"response\"), y = fit_bias$y, \n    main = \"Biased cost sampling\")\n\nA 95% confidence interval is given for the calibration intercept, calibration slope and c-statistic. \n\n          Dxy       C (ROC)            R2             D      D:Chi-sq \n 9.455531e-01  9.727765e-01  7.377389e-01  5.421879e-01  1.481173e+03 \n          D:p             U      U:Chi-sq           U:p             Q \n 0.000000e+00 -7.326007e-04  4.547474e-13  1.000000e+00  5.429205e-01 \n        Brier     Intercept         Slope          Emax  Brier scaled \n 4.639351e-02 -6.178465e-09  1.000000e+00  3.418414e-09  6.320478e-01 \n         Eavg           ECI \n 5.579221e-03  1.200259e-02 \n\nval.prob.ci.2(predict(fit_bias2, type = \"response\"), fit_bias2$y, main = \"Biased markup sampling\")\n\n\n\n\n\n\n\n\nCall:\nval.prob.ci.2(p = predict(fit_bias2, type = \"response\"), y = fit_bias2$y, \n    main = \"Biased markup sampling\")\n\nA 95% confidence interval is given for the calibration intercept, calibration slope and c-statistic. \n\n          Dxy       C (ROC)            R2             D      D:Chi-sq \n 9.377667e-01  9.688834e-01  7.293933e-01  5.629314e-01  1.517537e+03 \n          D:p             U      U:Chi-sq           U:p             Q \n 0.000000e+00 -7.423905e-04 -3.410605e-13  1.000000e+00  5.636738e-01 \n        Brier     Intercept         Slope          Emax  Brier scaled \n 5.170820e-02 -1.478349e-09  1.000000e+00  8.040748e-10  6.229804e-01 \n         Eavg           ECI \n 4.285675e-03  4.562992e-03"
  },
  {
    "objectID": "projects/logisticRegressionExample/index.html#footnotes",
    "href": "projects/logisticRegressionExample/index.html#footnotes",
    "title": "Logistic Regression Analysis Example: Optimizing Expected Returns",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThere is an extension of logistic regression to group level data where the outcome is the number of successes observed and is modeled as a binomial random variable.‚Ü©Ô∏é"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects",
    "section": "",
    "text": "Logistic Regression Analysis Example: Optimizing Expected Returns\n\n\n\nMachine Learning\n\nLogistic Regression\n\nOptimization\n\n\n\n\n\n\n\nJosh Tomiyama\n\n\nNovember 7, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "Joshua-Michael Tomiyama",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Post With Code\n\n\n\nnews\n\ncode\n\nanalysis\n\n\n\n\n\n\n\n\n\nJanuary 6, 2026\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJanuary 3, 2026\n\n\nTristan O‚ÄôMalley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/posts/welcome/index.html",
    "href": "blog/posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "blog/posts/post-with-code/index.html",
    "href": "blog/posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "projects/project_listing.html",
    "href": "projects/project_listing.html",
    "title": "Projects",
    "section": "",
    "text": "Logistic Regression Analysis Example: Optimizing Expected Returns\n\n\n\nMachine Learning\n\nLogistic Regression\n\nOptimization\n\n\n\n\n\n\n\nJosh Tomiyama\n\n\nNovember 7, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about/about.html",
    "href": "about/about.html",
    "title": "Joshua-Michael Tomiyama",
    "section": "",
    "text": "Aloha! My name is Joshua-Michael Tomiyama, but please call me Josh for short. I am a data scientist who specializes in building machine learning models on the admissions and enrollment of undergraduate students to improve higher education outcomes.\nIn addition to my work experience, I have an expansive range of academic research experience primarily in Bayesian statistics. Topics I‚Äôve studied include:\n\nspatio-temporal modeling of infectious diseases\napproximate Bayesian algorithm development\nBayesian non-parametric models\nmodel selection criteria for hierarchical models\n\nMy vision for this blog is to highlight interesting analyses I‚Äôve encountered, to explain complex statistical methods and concepts, and to document my journey learning new technical skills.\nIf you have any interesting topics or further inquiries about me or this blog please feel free to contact me at shakastats13@gmail.com.\nMahalo for stopping by ü§ôüèæ"
  },
  {
    "objectID": "blog/blog_listing.html",
    "href": "blog/blog_listing.html",
    "title": "Blog",
    "section": "",
    "text": "Post With Code\n\n\n\nnews\n\ncode\n\nanalysis\n\n\n\n\n\n\n\n\n\nJanuary 6, 2026\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJanuary 3, 2026\n\n\nTristan O‚ÄôMalley\n\n\n\n\n\nNo matching items"
  }
]